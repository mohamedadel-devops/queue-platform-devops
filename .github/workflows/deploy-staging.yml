name: Deploy Staging (SSM)

on:
  workflow_run:
    workflows: ["App CI - Build & Push"]
    types: [completed]

env:
  API_IMAGE: node-queue-api
  WORKER_IMAGE: node-queue-worker
  API_PORT: "3001"

jobs:
  deploy:
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    environment: staging

    steps:
      - name: Checkout (GitHub Action)
        uses: actions/checkout@v4

      - name: Configure AWS credentials (GitHub Action)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: eu-central-1

      - name: Deploy to Staging via SSM (AWS CLI + bash)
        env:
          INSTANCE_ID: ${{ secrets.STAGING_INSTANCE_ID }}
          NS: ${{ secrets.DOCKERHUB_NAMESPACE }}
          TAG: ${{ github.event.workflow_run.head_sha }}
          DH_USER: ${{ secrets.DOCKERHUB_USERNAME }}
          DH_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
        run: |
          set -e

          if [ -z "$INSTANCE_ID" ]; then
            echo "Missing STAGING_INSTANCE_ID (add it as a secret in the 'staging' environment)."
            exit 1
          fi

          # Base64-encode the compose file so we can safely send it through SSM
          COMPOSE_B64="$(base64 -w 0 app/compose/docker-compose.staging.yml)"

          # Send remote commands via SSM
          CMD_ID="$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --comment "Deploy staging (images tagged by commit SHA) + healthcheck + rollback" \
            --parameters "commands=[
              \"set -e\",
              \"mkdir -p ~/queue-platform && cd ~/queue-platform\",

              \"# Capture previous tag (if any) from running container\",
              \"PREV_TAG=''\",
              \"if docker ps --format '{{.Names}}' | grep -q '^api_staging$'; then PREV_IMAGE=$(docker inspect -f '{{.Config.Image}}' api_staging || true); PREV_TAG=$(echo \\\"$PREV_IMAGE\\\" | awk -F: '{print $2}'); fi\",
              \"echo Previous tag: $PREV_TAG\",

              \"# (Optional) Docker Hub login if your images are private\",
              \"if [ -n \\\"$DH_USER\\\" ] && [ -n \\\"$DH_TOKEN\\\" ]; then echo \\\"$DH_TOKEN\\\" | docker login -u \\\"$DH_USER\\\" --password-stdin; fi\",

              \"# Write runtime env used by docker compose image tags\",
              \"cat > .env <<EOF\",
              \"DOCKERHUB_NAMESPACE=$NS\",
              \"API_IMAGE=node-queue-api\",
              \"WORKER_IMAGE=node-queue-worker\",
              \"IMAGE_TAG=$TAG\",
              \"EOF\",

              \"# Write compose file from base64\",
              \"echo $COMPOSE_B64 | base64 -d > docker-compose.staging.yml\",

              \"# Deploy new version\",
              \"docker compose -f docker-compose.staging.yml pull\",
              \"docker compose -f docker-compose.staging.yml up -d\",

              \"# Healthcheck\",
              \"OK=0\",
              \"for i in {1..15}; do if curl -fsS http://localhost:${API_PORT}/health >/dev/null; then OK=1; break; fi; sleep 2; done\",
              \"if [ \\\"$OK\\\" = \\\"1\\\" ]; then echo Healthcheck OK; docker image prune -f; exit 0; fi\",

              \"echo Healthcheck FAILED - rollback\",
              \"if [ -n \\\"$PREV_TAG\\\" ]; then\",
              \"  cat > .env <<EOF\",
              \"DOCKERHUB_NAMESPACE=$NS\",
              \"API_IMAGE=node-queue-api\",
              \"WORKER_IMAGE=node-queue-worker\",
              \"IMAGE_TAG=$PREV_TAG\",
              \"EOF\",
              \"  docker compose -f docker-compose.staging.yml pull\",
              \"  docker compose -f docker-compose.staging.yml up -d\",
              \"  echo Rolled back to $PREV_TAG\",
              \"else\",
              \"  echo No previous tag found to rollback to\",
              \"fi\",
              \"exit 1\"
            ]" \
            --query "Command.CommandId" \
            --output text)"

          echo "SSM CommandId: $CMD_ID"

          # Wait until the command finishes (Success/Failed/TimedOut/Cancelled)
          for i in {1..60}; do
            STATUS="$(aws ssm get-command-invocation \
              --command-id "$CMD_ID" \
              --instance-id "$INSTANCE_ID" \
              --query "Status" \
              --output text 2>/dev/null || true)"

            echo "Status: $STATUS"
            case "$STATUS" in
              Success) exit 0 ;;
              Failed|TimedOut|Cancelled)
                echo "---- STDOUT ----"
                aws ssm get-command-invocation --command-id "$CMD_ID" --instance-id "$INSTANCE_ID" --query "StandardOutputContent" --output text || true
                echo "---- STDERR ----"
                aws ssm get-command-invocation --command-id "$CMD_ID" --instance-id "$INSTANCE_ID" --query "StandardErrorContent" --output text || true
                exit 1
                ;;
              InProgress|Pending|Delayed|"") sleep 5 ;;

